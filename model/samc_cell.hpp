/**
 * Copyright (c) 2020, Cristina Ruiz Martin
 * ARSLab - Carleton University
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 1. Redistributions of source code must retain the above copyright notice,
 * this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 * this list of conditions and the following disclaimer in the documentation
 * and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */
/**
* Model developed by Hoda Khalil in Cell-DEVS CD++
* Implemented in Cadmium-cell-DEVS by Cristina Ruiz Martin
*/

#ifndef CADMIUM_CELLDEVS_CO2_CELL_HPP
#define CADMIUM_CELLDEVS_CO2_CELL_HPP

#include <cmath>
#include <nlohmann/json.hpp>
#include <cadmium/celldevs/cell/grid_cell.hpp>

using nlohmann::json;
using namespace cadmium::celldevs;
using namespace std;

/************************************/
/******COMPLEX CONFIG STRUCTURE******/
/************************************/
struct conc {
    /*

    float co2_production; //CO2 generated by one person
    float cell_size;
    int base; //CO2 base level
    int window_conc; //CO2 level at window
    int vent_conc; //CO2 level at vent
    int resp_time;
	int breathing_rate;
	int time_active; //amount of time in states spent at workstation
	int start_time; //start state for workstation occupation

    // Each cell is 25cm x 25cm x 25cm = 15.626 Liters of air each
      // CO2 sources have their concentration continually increased by default by 12.16 ppm every 5 seconds.
    conc(): co2_production(0.0155), cell_size(25), base(500), resp_time(5), window_conc(400), vent_conc(400), breathing_rate(5), time_active(100), start_time(30) {}
    conc(float ci, float cs, int b, int wc, int vc, int r, int br, int ta, int st): co2_production(ci), cell_size(cs), base(b), resp_time(r), window_conc(wc), vent_conc(vc), breathing_rate(br), time_active(ta), start_time(st) {}

    */
};
void from_json(const json& j, conc &c) {
}


/************************************/
/******COMPLEX STATE STRUCTURE*******/
/************************************/
struct samc {
    double permeability;
    double lethality;
    double population;
    double deaths;

    vector<pair<cell_position, double>> travel_rate;

    //samc() : counter(-1), concentration(500), type(AIR), breathing_counter(0) {}  // a default constructor is required
    //samc(int i_counter, int i_concentration, CELL_TYPE i_type, int i_breathing_counter) : counter(i_counter), concentration(i_concentration), type(i_type), breathing_counter(i_breathing_counter){}
};

// Required if you want to use transport delay (priority queue has to sort messages somehow)
inline bool operator<(const samc& lhs, const samc& rhs){
    if(lhs.permeability != rhs.permeability){
        return lhs.permeability < rhs.permeability;
    }else if(lhs.lethality != rhs.lethality){
        return lhs.lethality < rhs.lethality;
    }else if(lhs.population != rhs.population){
        return lhs.population < rhs.population;
    }else if(lhs.deaths != rhs.deaths){
        return lhs.deaths < rhs.deaths;
    }else{
        return lhs.travel_rate.size() < rhs.travel_rate.size();
    }
}
inline bool operator>=(const samc& lhs, const samc& rhs){return !(lhs<rhs);}
inline bool operator>(const samc& lhs, const samc& rhs){return rhs < lhs;}
inline bool operator<=(const samc& lhs, const samc& rhs){return !(rhs<lhs);}

// Required for comparing states and detect any change
inline bool operator== (const samc &lhs, const samc &rhs) {
    return false;//I get domain errors if it ever pacivates, so I stop it from pacivating ever
    /*
    return lhs.permeability       == rhs.permeability &&
           lhs.lethality          == rhs.lethality    &&
           lhs.population         == rhs.population   &&
           lhs.deaths             == rhs.deaths       &&
           lhs.travel_rate.size() == rhs.travel_rate.size();*/
}
inline bool operator!=(const samc &lhs, const samc &rhs){return !(lhs==rhs);}


// Required for printing the state of the cell
std::ostream &operator << (std::ostream &os, const samc &x) {
    os << "[" << x.permeability << ", " << x.lethality << ", " << x.population << ", " << x.deaths << "]";
    return os;
}

void from_json(const json& j, samc &s) {
    j.at("permeability").get_to(s.permeability);
    j.at("lethality").get_to(s.lethality);
    j.at("population").get_to(s.population);
    j.at("deaths").get_to(s.deaths);
}

template <typename TIME>
class samc_cell : public grid_cell<TIME, samc> {
public:
    using grid_cell<TIME, samc, int>::simulation_clock;
    using grid_cell<TIME, samc, int>::state;
    using grid_cell<TIME, samc, int>::map;
    using grid_cell<TIME, samc, int>::neighbors;
    using grid_cell<TIME, samc, int>::cell_id;

    using config_type = conc;  // IMPORTANT FOR THE JSON

    samc_cell() : grid_cell<TIME, samc, int>() {
    }

    samc_cell(
            cell_position const &cell_id,
            cell_unordered<int> const &neighborhood,
            samc initial_state,
            cell_map<samc, int> const &map_in,
            std::string const &delayer_id,
            conc) :
        grid_cell<TIME, samc>(cell_id, neighborhood, initial_state, map_in, delayer_id) {}

    samc local_computation() const override {
        //cout << simulation_clock << " " << cell_id << "\n";
        samc new_state = state.current_state;

        if(new_state.travel_rate.size() == 0){
            // First time through, create travel_rate cache
            double living = 1-new_state.lethality;
            double total_permiability = 0;

            for(auto n_id : neighbors){
                total_permiability += state.neighbors_state.at(n_id).permeability;
            }
            double scalar = 0;
            if(total_permiability){
                scalar = living/total_permiability;
            }
            for(auto n_id : neighbors){
                new_state.travel_rate.push_back({n_id, scalar*state.neighbors_state.at(n_id).permeability});
            }
        }else{

            //new_state.deaths += 1;
            // pop*lethality creatures die, and then the remaining move
            new_state.deaths += state.current_state.population*state.current_state.lethality;

            double new_pop = 0;
            //new_state.population += 1;

            for(const auto n_id : neighbors){
                for(const auto &[p_id, t_r] : state.neighbors_state.at(n_id).travel_rate){
                    if(p_id == cell_id){
                        new_pop += state.neighbors_state.at(n_id).population * t_r;
                    }
                }
            }
            new_state.population = new_pop;
        }

        return new_state;
    }


    // It returns the delay to communicate cell's new state.
    TIME output_delay(const samc&) const override {
    	return 1;
    }

};

#endif //CADMIUM_CELLDEVS_CO2_CELL_HPP













